{"ast":null,"code":"import fetch from 'isomorphic-unfetch';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport { User } from '../../../models';\nimport { PRIVATEKEY } from '../../../config';\nexport default (async (req, res) => {\n  // const getUser = async obj => {\n  //     return await User.findOne({\n  //       where: obj,\n  //     });\n  //   };\n  //   if (req.method === 'POST') {\n  //     const { username, password } = await req.body; \n  //const url = `https://api.github.com/users/${username}`\n  try {\n    let errors = {}; // const getUser = async obj => {\n    //     return await User.findOne({\n    //       where: obj,\n    //     });\n    //   };\n\n    if (req.method === 'POST') {\n      const {\n        username,\n        password\n      } = req.body;\n      User.findOne({\n        where: {\n          username: username\n        }\n      }).then(user => {\n        if (!user) {\n          let error = {};\n          errors.email = \"No Account Found\"; // const error = new Error(errors.email)\n\n          error.response = \"No Account Found\";\n          res.status(400).json(error); //  throw error\n        }\n\n        bcrypt.compare(password, user.password).then(isMatch => {\n          if (isMatch) {\n            // const id  = user.id\n            // return res.status(200).json({ token: id })\n            const payload = {\n              id: user.id,\n              username: user.username,\n              email: user.email\n            };\n            let token = jwt.sign(payload, PRIVATEKEY);\n            res.json({\n              msg: 'ok',\n              token: `${token}`,\n              user: user\n            }); // jwt.sign(payload, secret, { expiresIn: 36000 },\n            //         (err, token) => {\n            //           if (err) res.status(500)\n            //           .json({ error: \"Error signing token\",\n            //                  raw: err }); \n            //            res.status(200).json({ \n            //            msg: ok,\n            //            token: `Bearer ${token}` });\n            // });      \n          } else {\n            errors.password = \"Password is incorrect\";\n            error.response = \"Password is incorrect\";\n            res.status(400).json(error);\n          }\n        });\n      });\n    } //     const response = await fetch(url)\n    //     if (response.ok) {\n    //       const { id } = await response.json()\n    //       return res.status(200).json({ token: id })\n    //     } else {\n    //       // https://github.com/developit/unfetch#caveats\n    //       const error = new Error(response.statusText)\n    //       error.response = response\n    //       throw error\n    //     }\n\n  } catch (error) {\n    const {\n      response\n    } = error;\n    return response ? res.status(response.status).json({\n      response: response.statusText\n    }) : res.status(400).json({\n      response: error.message\n    });\n  }\n}); //}","map":{"version":3,"sources":["C:/src/hottofindtest/pages/api/auth/signin.js"],"names":["fetch","jwt","bcrypt","User","PRIVATEKEY","req","res","errors","method","username","password","body","findOne","where","then","user","error","email","response","status","json","compare","isMatch","payload","id","token","sign","msg","statusText","message"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,oBAAlB;AACA,OAAOC,GAAP,MAAgB,cAAhB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,SAASC,IAAT,QAAoB,iBAApB;AACA,SAAQC,UAAR,QAAyB,iBAAzB;AAGA,gBAAe,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AAE/B;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEF;AAEA,MAAI;AAEN,QAAIC,MAAM,GAAG,EAAb,CAFM,CAKF;AACA;AACA;AACA;AACA;;AAGA,QAAIF,GAAG,CAACG,MAAJ,KAAe,MAAnB,EAA2B;AAEzB,YAAM;AAAEC,QAAAA,QAAF;AAAYC,QAAAA;AAAZ,UAAyBL,GAAG,CAACM,IAAnC;AACAR,MAAAA,IAAI,CAACS,OAAL,CAAa;AACXC,QAAAA,KAAK,EAAE;AAAEJ,UAAAA,QAAQ,EAAEA;AAAZ;AADI,OAAb,EAGMK,IAHN,CAGWC,IAAI,IAAI;AAEX,YAAI,CAACA,IAAL,EAAW;AACT,cAAIC,KAAK,GAAG,EAAZ;AACCT,UAAAA,MAAM,CAACU,KAAP,GAAe,kBAAf,CAFQ,CAGT;;AACCD,UAAAA,KAAK,CAACE,QAAN,GAAiB,kBAAjB;AACAZ,UAAAA,GAAG,CAACa,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBJ,KAArB,EALQ,CAMV;AACD;;AACDd,QAAAA,MAAM,CAACmB,OAAP,CAAeX,QAAf,EAAyBK,IAAI,CAACL,QAA9B,EACQI,IADR,CACaQ,OAAO,IAAI;AACd,cAAIA,OAAJ,EAAa;AAEZ;AACA;AAEC,kBAAMC,OAAO,GAAG;AACdC,cAAAA,EAAE,EAAET,IAAI,CAACS,EADK;AAEdf,cAAAA,QAAQ,EAAEM,IAAI,CAACN,QAFD;AAGdQ,cAAAA,KAAK,EAAEF,IAAI,CAACE;AAHE,aAAhB;AAMD,gBAAIQ,KAAK,GAAGxB,GAAG,CAACyB,IAAJ,CAASH,OAAT,EAAkBnB,UAAlB,CAAZ;AACAE,YAAAA,GAAG,CAACc,IAAJ,CAAS;AAAEO,cAAAA,GAAG,EAAE,IAAP;AAAaF,cAAAA,KAAK,EAAG,GAAEA,KAAM,EAA7B;AAAgCV,cAAAA,IAAI,EAAEA;AAAtC,aAAT,EAZY,CAcZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACL,WAvBI,MAuBE;AACHR,YAAAA,MAAM,CAACG,QAAP,GAAkB,uBAAlB;AACAM,YAAAA,KAAK,CAACE,QAAN,GAAkB,uBAAlB;AACAZ,YAAAA,GAAG,CAACa,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBJ,KAArB;AACX;AACF,SA9BI;AA+BN,OA5CD;AA6CD,KA5DC,CA+DN;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIG,GA7ED,CA6EE,OAAOA,KAAP,EAAc;AAGd,UAAM;AAAEE,MAAAA;AAAF,QAAeF,KAArB;AACA,WAAOE,QAAQ,GACXZ,GAAG,CAACa,MAAJ,CAAWD,QAAQ,CAACC,MAApB,EAA4BC,IAA5B,CAAiC;AAAEF,MAAAA,QAAQ,EAAEA,QAAQ,CAACU;AAArB,KAAjC,CADW,GAEXtB,GAAG,CAACa,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEF,MAAAA,QAAQ,EAAEF,KAAK,CAACa;AAAlB,KAArB,CAFJ;AAGD;AAEF,CApGD,E,CAqGA","sourcesContent":["import fetch from 'isomorphic-unfetch'\r\nimport jwt from 'jsonwebtoken';\r\nimport bcrypt from 'bcryptjs';\r\nimport { User} from '../../../models';\r\nimport {PRIVATEKEY} from '../../../config'\r\n\r\n\r\nexport default async (req, res) => {\r\n\r\n    // const getUser = async obj => {\r\n    //     return await User.findOne({\r\n    //       where: obj,\r\n    //     });\r\n    //   };\r\n\r\n    //   if (req.method === 'POST') {\r\n\r\n    //     const { username, password } = await req.body; \r\n\r\n  //const url = `https://api.github.com/users/${username}`\r\n\r\n  try {\r\n\r\nlet errors = {}\r\n\r\n\r\n    // const getUser = async obj => {\r\n    //     return await User.findOne({\r\n    //       where: obj,\r\n    //     });\r\n    //   };\r\n\r\n      \r\n    if (req.method === 'POST') {\r\n\r\n      const { username, password } = req.body; \r\n      User.findOne({ \r\n        where: { username: username },\r\n      })\r\n           .then(user => {\r\n            \r\n              if (!user) {\r\n                let error = {}\r\n                 errors.email = \"No Account Found\";\r\n                // const error = new Error(errors.email)\r\n                 error.response = \"No Account Found\"\r\n                 res.status(400).json(error);\r\n               //  throw error\r\n             }\r\n             bcrypt.compare(password, user.password)\r\n                    .then(isMatch => {\r\n                       if (isMatch) {\r\n\r\n                        // const id  = user.id\r\n                        // return res.status(200).json({ token: id })\r\n                    \r\n                         const payload = {\r\n                           id: user.id,\r\n                           username: user.username,\r\n                           email: user.email\r\n                        };\r\n\r\n                        let token = jwt.sign(payload, PRIVATEKEY)\r\n                        res.json({ msg: 'ok', token: `${token}`, user: user });\r\n\r\n                        // jwt.sign(payload, secret, { expiresIn: 36000 },\r\n                        //         (err, token) => {\r\n                        //           if (err) res.status(500)\r\n                        //           .json({ error: \"Error signing token\",\r\n                        //                  raw: err }); \r\n                        //            res.status(200).json({ \r\n                        //            msg: ok,\r\n                        //            token: `Bearer ${token}` });\r\n                        // });      \r\n                  } else {\r\n                      errors.password = \"Password is incorrect\"; \r\n                      error.response =  \"Password is incorrect\";                 \r\n                      res.status(400).json(error);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    \r\n//     const response = await fetch(url)\r\n\r\n//     if (response.ok) {\r\n//       const { id } = await response.json()\r\n//       return res.status(200).json({ token: id })\r\n//     } else {\r\n//       // https://github.com/developit/unfetch#caveats\r\n//       const error = new Error(response.statusText)\r\n//       error.response = response\r\n//       throw error\r\n//     }\r\n\r\n\r\n    \r\n  } catch (error) {\r\n\r\n\r\n    const { response } = error\r\n    return response\r\n      ? res.status(response.status).json({ response: response.statusText })\r\n      : res.status(400).json({ response: error.message })\r\n  }\r\n\r\n}\r\n//}\r\n"]},"metadata":{},"sourceType":"module"}